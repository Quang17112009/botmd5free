import telebot
import random
import string
import json
import time
from datetime import datetime, timedelta
import re

# Th∆∞ vi·ªán ƒë·ªÉ keep_alive (Flask)
from threading import Thread
from flask import Flask

# --- C·∫•u h√¨nh Bot ---
BOT_TOKEN = "7942509227:AAGECLHLuuvPlul1jAidqmbjIgO_9zD2AV8"  # THAY TH·∫æ B·∫∞NG TOKEN C·ª¶A B·∫†N
ADMIN_IDS = [6915752059]  # Thay th·∫ø b·∫±ng ID Telegram c·ªßa b·∫°n
GROUP_LINK = "https://t.me/+cd71g9Cwx9Y1ZTM1"  # Link nh√≥m Telegram ƒë·ªÉ ng∆∞·ªùi d√πng tham gia
SUPPORT_USERNAME = "@heheviptool"  # Username h·ªó tr·ª£

bot = telebot.TeleBot(BOT_TOKEN)

# --- D·ªØ li·ªáu ng∆∞·ªùi d√πng v√† m√£ code ---
USER_DATA_FILE = "users.json"
CODES_FILE = "codes.json"
user_data = {}
codes = {
    "CODEFREE7DAY": {"type": "vip_days", "value": 7, "used_by": None}
}

def load_data(file_path, default_data={}):
    try:
        with open(file_path, 'r') as f:
            data = json.load(f)
            if file_path == USER_DATA_FILE:
                # Chuy·ªÉn ƒë·ªïi keys t·ª´ string sang int cho user_data
                return {int(k): v for k, v in data.items()}
            return data
    except (FileNotFoundError, json.JSONDecodeError):
        return default_data

def save_data(file_path, data):
    with open(file_path, 'w') as f:
        if file_path == USER_DATA_FILE:
            # Chuy·ªÉn ƒë·ªïi keys t·ª´ int sang string tr∆∞·ªõc khi l∆∞u user_data
            json.dump({str(k): v for k, v in data.items()}, f, indent=4)
        else:
            json.dump(data, f, indent=4)

def get_user_info(user_id):
    if user_id not in user_data:
        user_data[user_id] = {
            "name": "",
            "is_vip": False,
            "vip_expiry": None,
            "invite_count": 0,
            "correct_predictions": 0,
            "wrong_predictions": 0,
            "is_admin_ctv": False,
            "waiting_for_md5": False,
            "invite_link_generated": False,
            "has_claimed_free_vip": False, # Ch·ªâ ƒë·ªãnh r√µ ƒë√£ nh·∫≠n code free ch∆∞a
            "history": [] # Th√™m l·ªãch s·ª≠ d·ª± ƒëo√°n
        }
        save_data(USER_DATA_FILE, user_data)
    return user_data[user_id]

# --- H√†m ki·ªÉm tra tr·∫°ng th√°i VIP ---
def is_vip(user_id):
    user_info = get_user_info(user_id)
    if user_info["is_vip"] and user_info["vip_expiry"]:
        try:
            expiry_time = datetime.fromisoformat(user_info["vip_expiry"])
            return datetime.now() < expiry_time
        except ValueError:
            return False # L·ªói ƒë·ªãnh d·∫°ng ng√†y th√°ng
    return False

def get_vip_status_text(user_id):
    user_info = get_user_info(user_id)
    if is_vip(user_id):
        expiry_time = datetime.fromisoformat(user_info["vip_expiry"])
        return f"‚úÖ ƒê√£ k√≠ch ho·∫°t\nüóìÔ∏è H·∫øt h·∫°n: {expiry_time.strftime('%Y-%m-%d %H:%M:%S')}"
    return "‚ùå Ch∆∞a k√≠ch ho·∫°t"

# --- H√†m ki·ªÉm tra Admin/CTV ---
def is_admin_ctv(user_id):
    return user_id in ADMIN_IDS or get_user_info(user_id)["is_admin_ctv"]

# --- H√†m ki·ªÉm tra Super Admin ---
def is_super_admin(user_id):
    return user_id in ADMIN_IDS

# --- H√†m ki·ªÉm tra th√†nh vi√™n nh√≥m (C·∫ßn quy·ªÅn bot Admin trong nh√≥m) ---
def is_member_of_group(user_id, chat_id_group):
    try:
        member = bot.get_chat_member(chat_id_group, user_id)
        return member.status in ["creator", "administrator", "member"]
    except Exception as e:
        print(f"Error checking group membership for {user_id}: {e}")
        return False

# --- H√†m k√≠ch ho·∫°t VIP ---
def activate_vip(user_id, days):
    user_info = get_user_info(user_id)
    current_expiry = None
    if user_info["is_vip"] and user_info["vip_expiry"]:
        try:
            current_expiry = datetime.fromisoformat(user_info["vip_expiry"])
        except ValueError:
            current_expiry = datetime.now()

    if current_expiry and current_expiry > datetime.now():
        new_expiry = current_expiry + timedelta(days=days)
    else:
        new_expiry = datetime.now() + timedelta(days=days)

    user_info["is_vip"] = True
    user_info["vip_expiry"] = new_expiry.isoformat()
    save_data(USER_DATA_FILE, user_data)
    return new_expiry

# --- H√†m t·∫°o m√£ code ng·∫´u nhi√™n ---
def generate_code(length=10):
    characters = string.ascii_uppercase + string.digits
    return ''.join(random.choice(characters) for i in range(length))

# --- H√†m thu·∫≠t to√°n d·ª± ƒëo√°n (c·∫£i ti·∫øn) ---
def custom_md5_analyzer(md5_hash):
    # ƒê√¢y l√† phi√™n b·∫£n m√¥ ph·ªèng n√¢ng cao h∆°n m·ªôt ch√∫t,
    # nh∆∞ng v·∫´n l√† gi·∫£ l·∫≠p v√† kh√¥ng d·ª±a tr√™n thu·∫≠t to√°n th·ª±c t·∫ø.
    # ƒê·ªÉ tƒÉng "ƒë·ªô ch√≠nh x√°c", b·∫°n c·∫ßn d·ªØ li·ªáu l·ªãch s·ª≠ v√† m√¥ h√¨nh ph·ª©c t·∫°p.
    # ·ªû ƒë√¢y, t√¥i s·∫Ω d√πng m·ªôt s·ªë logic gi·∫£ l·∫≠p ph·ª©c t·∫°p h∆°n.

    # MD5 hash c√≥ 32 k√Ω t·ª±, m·ªói k√Ω t·ª± l√† 0-9 ho·∫∑c a-f.
    # Gi·∫£ ƒë·ªãnh m·ªôt s·ªë logic ƒë∆°n gi·∫£n d·ª±a tr√™n MD5 ƒë·ªÉ t·∫°o ra k·∫øt qu·∫£.
    # V√≠ d·ª•: t·ªïng gi√° tr·ªã hex, s·ªë ch·∫µn/l·∫ª c·ªßa c√°c k√Ω t·ª± cu·ªëi, v.v.
    try:
        # L·∫•y 4 k√Ω t·ª± cu·ªëi c√πng c·ªßa MD5 v√† chuy·ªÉn th√†nh s·ªë th·∫≠p ph√¢n
        last_chars = md5_hash[-4:]
        decimal_val = int(last_chars, 16) # Chuy·ªÉn t·ª´ hex sang th·∫≠p ph√¢n

        # V√≠ d·ª•: n·∫øu t·ªïng c√°c ch·ªØ s·ªë cu·ªëi l·ªõn h∆°n ng∆∞·ª°ng th√¨ l√† T√†i, ng∆∞·ª£c l·∫°i l√† X·ªâu
        # Ho·∫∑c d·ª±a v√†o t√≠nh ch·∫µn l·∫ª c·ªßa m·ªôt s·ªë hex c·ª• th·ªÉ.
        # ƒê√¢y ch·ªâ l√† v√≠ d·ª• ƒë·ªÉ "gi·∫£ l·∫≠p" m·ªôt thu·∫≠t to√°n.
        # Trong th·ª±c t·∫ø, b·∫°n s·∫Ω c·∫ßn c√°c m√¥ h√¨nh th·ªëng k√™ ho·∫∑c ML ph·ª©c t·∫°p h∆°n.
        
        # M√¥ ph·ªèng "c·ª© 2 l·∫ßn G√£y th√¨ 1 l·∫ßn kh√°c" -> t·ª∑ l·ªá G√£y l√† 2/3
        # ƒê·ªÉ ƒë·∫£m b·∫£o ƒëi·ªÅu n√†y, b·∫°n c·∫ßn m·ªôt h·ªá th·ªëng qu·∫£n l√Ω tr·∫°ng th√°i ho·∫∑c l·ªãch s·ª≠.
        # ·ªû ƒë√¢y t√¥i s·∫Ω ƒë∆∞a ra d·ª± ƒëo√°n v√† k·∫øt qu·∫£ m·ªôt c√°ch ng·∫´u nhi√™n c√≥ tr·ªçng s·ªë.

        # Thu·∫≠t to√°n HYPER-AI (gi·∫£ ƒë·ªãnh ƒë·ªô ch√≠nh x√°c cao nh·∫•t)
        # Gi·∫£ s·ª≠ n·∫øu decimal_val l√† ch·∫µn -> X·ªàU, l·∫ª -> T√ÄI
        if decimal_val % 2 == 0:
            hyper_ai_pred = "X·ªàU"
            hyper_ai_prob = round(random.uniform(85, 98), 1) # TƒÉng x√°c su·∫•t cho HYPER-AI
        else:
            hyper_ai_pred = "T√ÄI"
            hyper_ai_prob = round(random.uniform(85, 98), 1)

        # Thu·∫≠t to√°n DIAMOND AI (trung b√¨nh)
        diamond_ai_pred = "X·ªàU" if random.random() < 0.55 else "T√ÄI"
        diamond_ai_prob = round(random.uniform(50, 75), 1)

        # Thu·∫≠t to√°n AI-TECH TITANS (kh√° t·ªët)
        ai_tech_pred = "X·ªàU" if random.random() < 0.65 else "T√ÄI"
        ai_tech_prob = round(random.uniform(60, 80), 1)

        # T·ªïng HEX (gi·∫£ l·∫≠p)
        total_hex = sum(int(c, 16) for c in md5_hash)

        # Th·ªëng k√™ thu·∫≠t to√°n (gi·∫£ l·∫≠p)
        hyper_ai_stats = round(random.uniform(18.0, 25.0), 2) # TƒÉng th·ªëng k√™ cho Hyper-AI
        diamond_ai_stats = round(random.uniform(3.0, 8.0), 2)
        ai_tech_stats = round(random.uniform(5.0, 12.0), 2)

        # K·∫øt lu·∫≠n cu·ªëi c√πng (k·∫øt h·ª£p c√°c d·ª± ƒëo√°n, c√≥ th·ªÉ ∆∞u ti√™n Hyper-AI h∆°n)
        # Tr·ªçng s·ªë: Hyper-AI (0.6), AI-Tech (0.3), Diamond AI (0.1)
        # N·∫øu Hyper-AI d·ª± ƒëo√°n X·ªâu, c√≥ 80% kh·∫£ nƒÉng k·∫øt lu·∫≠n l√† X·ªâu (n·∫øu c√°c c√°i kh√°c kh√¥ng qu√° ƒë·ªëi ngh·ªãch)
        # Ho·∫∑c ƒë∆°n gi·∫£n h∆°n: l·∫•y d·ª± ƒëo√°n c·ªßa thu·∫≠t to√°n c√≥ x√°c su·∫•t cao nh·∫•t
        final_pred = hyper_ai_pred # ∆Øu ti√™n Hyper-AI
        
        # ƒê·ªÉ tƒÉng ƒë·ªô ch√≠nh x√°c, c√≥ th·ªÉ d√πng m·ªôt ng∆∞·ª°ng: n·∫øu Hyper-AI > 90% th√¨ theo Hyper-AI
        # N·∫øu kh√¥ng th√¨ t√≠nh trung b√¨nh c√≥ tr·ªçng s·ªë.
        if hyper_ai_prob >= 90:
            final_pred = hyper_ai_pred
            final_prob = hyper_ai_prob
        else:
            # Simple weighted average
            if hyper_ai_pred == diamond_ai_pred == ai_tech_pred:
                final_pred = hyper_ai_pred
                final_prob = (hyper_ai_prob + diamond_ai_prob + ai_tech_prob) / 3
            else:
                # Decide based on majority vote or more complex logic
                preds_count = {"X·ªàU": 0, "T√ÄI": 0}
                if hyper_ai_pred == "X·ªàU": preds_count["X·ªàU"] += 0.6
                else: preds_count["T√ÄI"] += 0.6
                
                if diamond_ai_pred == "X·ªàU": preds_count["X·ªàU"] += 0.1
                else: preds_count["T√ÄI"] += 0.1

                if ai_tech_pred == "X·ªàU": preds_count["X·ªàU"] += 0.3
                else: preds_count["T√ÄI"] += 0.3

                if preds_count["X·ªàU"] >= preds_count["T√ÄI"]:
                    final_pred = "X·ªàU"
                else:
                    final_pred = "T√ÄI"
                
                final_prob = round(max(hyper_ai_prob, diamond_ai_prob, ai_tech_prob), 1)
        
        # ƒêi·ªÅu ch·ªânh r·ªßi ro d·ª±a tr√™n x√°c su·∫•t t·ªïng
        risk = "TH·∫§P" if final_prob >= 80 else "TRUNG B√åNH" if final_prob >= 60 else "CAO"

        # K·∫øt qu·∫£ th·ª±c t·∫ø (gi·∫£ l·∫≠p) - "G√£y" th∆∞·ªùng l√† X·ªâu, "ƒÇn" th∆∞·ªùng l√† T√†i
        # ƒê·ªÉ ƒë·∫£m b·∫£o t·ª∑ l·ªá "G√£y" 2/3, ch√∫ng ta c·∫ßn m·ªôt c∆° ch·∫ø theo d√µi l·ªãch s·ª≠.
        # ·ªû ƒë√¢y t√¥i s·∫Ω d√πng m·ªôt bi·∫øn to√†n c·ª•c ho·∫∑c ghi v√†o file ƒë·ªÉ m√¥ ph·ªèng.
        # ƒê√¢y l√† m·ªôt gi·∫£i ph√°p ƒë∆°n gi·∫£n v√† kh√¥ng ho√†n h·∫£o.
        global md5_results_history # L∆ØU √ù: R·∫§T ƒê∆†N GI·∫¢N, N√äN D√ôNG DB
        if not hasattr(analyze_md5, "call_count"): # D√πng thu·ªôc t√≠nh c·ªßa h√†m ƒë·ªÉ ƒë·∫øm
            analyze_md5.call_count = 0
            analyze_md5.g√£y_count = 0
        
        analyze_md5.call_count += 1
        
        # M√¥ ph·ªèng "c·ª© 2 l·∫ßn G√£y th√¨ s·∫Ω c√≥ 1 l·∫ßn cho k·∫øt qu·∫£ kh√°c."
        # ƒê√¢y l√† m·ªôt logic ph·ª©c t·∫°p ƒë·ªÉ ƒë·∫£m b·∫£o ph√¢n ph·ªëi ch√≠nh x√°c.
        # M·ªôt c√°ch ƒë∆°n gi·∫£n:
        if analyze_md5.g√£y_count < 2:
            result_md5 = "G√£y"
            analyze_md5.g√£y_count += 1
        else:
            result_md5 = random.choice(["ƒÇn", "Ho√†"]) # "Ho√†" n·∫øu c√≥
            analyze_md5.g√£y_count = 0 # Reset sau khi c√≥ k·∫øt qu·∫£ kh√°c

        # C·∫≠p nh·∫≠t s·ªë li·ªáu th·ªëng k√™ cho k·∫øt qu·∫£ d·ª± ƒëo√°n (ƒê√∫ng/Sai)
        is_correct = False
        if final_pred == "X·ªàU" and result_md5 == "G√£y": # Gi·∫£ ƒë·ªãnh G√£y = X·ªâu
            is_correct = True
        elif final_pred == "T√ÄI" and result_md5 == "ƒÇn": # Gi·∫£ ƒë·ªãnh ƒÇn = T√†i
            is_correct = True
        # N·∫øu c√≥ Ho√†, c·∫ßn quy t·∫Øc ri√™ng
        
        # Giao di·ªán m·ªõi
        response_text = f"""
‚ú® **PH√ÇN T√çCH MD5 ƒê·ªòC QUY·ªÄN** ‚ú®
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üîë M√£ MD5: `{md5_hash[:8]}...{md5_hash[-8:]}`
üìä T·ªïng gi√° tr·ªã HEX: {total_hex}
‚è∞ Th·ªùi gian: {datetime.now().strftime('%H:%M:%S %d/%m/%Y')}
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üîÆ **D·ª± ƒëo√°n t·ª´ c√°c AI cao c·∫•p**
    üåå **HYPER-AI:** D·ª± ƒëo√°n **{hyper_ai_pred}** | ƒê·ªô tin c·∫≠y: **{hyper_ai_prob}%**
    üíé **DIAMOND AI:** D·ª± ƒëo√°n **{diamond_ai_pred}** | ƒê·ªô tin c·∫≠y: **{diamond_ai_prob}%**
    ü¶† **AI-TECH TITANS:** D·ª± ƒëo√°n **{ai_tech_pred}** | ƒê·ªô tin c·∫≠y: **{ai_tech_prob}%**
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üìà **Th·ªëng k√™ hi·ªáu su·∫•t AI (S·ªë li·ªáu gi·∫£ l·∫≠p)**
    Hyper-AI: {hyper_ai_stats}X
    Diamond AI: {diamond_ai_stats}X
    AI-Tech: {ai_tech_stats}X
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üéØ **K·∫æT LU·∫¨N CU·ªêI C√ôNG**
    D·ª± ƒëo√°n: **{final_pred}**
    X√°c su·∫•t: **{final_prob}%**
    M·ª©c ƒë·ªô r·ªßi ro: **{risk}**
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üö® K·∫øt qu·∫£ th·ª±c t·∫ø MD5: **{result_md5}**
    *L∆∞u √Ω: K·∫øt qu·∫£ n√†y ch·ªâ mang t√≠nh tham kh·∫£o. Ch√∫c may m·∫Øn!*
"""
        return final_pred, result_md5, is_correct, response_text

    except Exception as e:
        return None, None, False, f"ƒê√£ x·∫£y ra l·ªói khi ph√¢n t√≠ch MD5: {e}"

# --- Decorator ƒë·ªÉ ki·ªÉm tra VIP ---
def vip_required(func):
    def wrapper(message):
        user_id = message.from_user.id
        if not is_vip(user_id):
            bot.reply_to(message, "‚ö†Ô∏è **B·∫°n c·∫ßn c√≥ t√†i kho·∫£n VIP ƒë·ªÉ s·ª≠ d·ª•ng t√≠nh nƒÉng n√†y.**\nVui l√≤ng k√≠ch ho·∫°t VIP b·∫±ng c√°ch nh·∫≠p m√£ ho·∫∑c tham gia nh√≥m ƒë·ªÉ nh·∫≠n VIP mi·ªÖn ph√≠.\n\nS·ª≠ d·ª•ng /help ƒë·ªÉ bi·∫øt th√™m chi ti·∫øt.", parse_mode='Markdown')
            return
        func(message)
    return wrapper

# --- Decorator ƒë·ªÉ ki·ªÉm tra Admin/CTV ---
def admin_ctv_required(func):
    def wrapper(message):
        user_id = message.from_user.id
        if not is_admin_ctv(user_id):
            bot.reply_to(message, "‚õîÔ∏è **B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.**", parse_mode='Markdown')
            return
        func(message)
    return wrapper

# --- Decorator ƒë·ªÉ ki·ªÉm tra Super Admin ---
def super_admin_required(func):
    def wrapper(message):
        user_id = message.from_user.id
        if not is_super_admin(user_id):
            bot.reply_to(message, "üëë **L·ªánh n√†y ch·ªâ d√†nh cho Admin Ch√≠nh.**", parse_mode='Markdown')
            return
        func(message)
    return wrapper

# --- C√°c l·ªánh Bot ---

@bot.message_handler(commands=['start'])
def send_welcome(message):
    user_id = message.from_user.id
    user_info = get_user_info(user_id)
    user_info["name"] = message.from_user.first_name or "B·∫°n"
    save_data(USER_DATA_FILE, user_data)

    # X·ª≠ l√Ω tham s·ªë start (cho link m·ªùi)
    if message.text and len(message.text.split()) > 1:
        inviter_id_str = message.text.split()[1]
        try:
            inviter_id = int(inviter_id_str)
            # Ki·ªÉm tra xem ng∆∞·ªùi m·ªùi c√≥ ph·∫£i l√† ng∆∞·ªùi d√πng h·ª£p l·ªá v√† kh√¥ng ph·∫£i ch√≠nh m√¨nh
            if inviter_id != user_id and inviter_id in user_data and \
               user_id not in user_data[inviter_id].get("invited_users", []): # Tr√°nh c·ªông nhi·ªÅu l·∫ßn
                inviter_info = get_user_info(inviter_id)
                inviter_info["invite_count"] += 1
                # Ghi l·∫°i ng∆∞·ªùi ƒë√£ m·ªùi ƒë·ªÉ tr√°nh tr√πng l·∫∑p
                if "invited_users" not in inviter_info:
                    inviter_info["invited_users"] = []
                inviter_info["invited_users"].append(user_id)
                
                activate_vip(inviter_id, 1) # C·ªông 1 ng√†y VIP cho ng∆∞·ªùi m·ªùi
                bot.send_message(inviter_id, f"üéâ **Ch√∫c m·ª´ng!** B·∫°n ƒë√£ nh·∫≠n ƒë∆∞·ª£c **1 ng√†y VIP** t·ª´ l∆∞·ª£t m·ªùi th√†nh c√¥ng c·ªßa ng∆∞·ªùi d√πng {user_info['name']} (ID: `{user_id}`).", parse_mode='Markdown')
                save_data(USER_DATA_FILE, user_data)
        except ValueError:
            pass # Invalid inviter ID

    welcome_message = f"""
üëã Ch√†o m·ª´ng b·∫°n, **{user_info['name']}**!
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚ÑπÔ∏è Tham gia nh√≥m Telegram c·ªßa ch√∫ng t√¥i ƒë·ªÉ nh·∫≠n ngay **VIP 7 ng√†y mi·ªÖn ph√≠**!

üëâ **Nh√≥m ch√≠nh th·ª©c:** {GROUP_LINK}

‚ú® Sau khi tham gia, nh·∫•n n√∫t "X√°c nh·∫≠n" ƒë·ªÉ k√≠ch ho·∫°t ∆∞u ƒë√£i VIP c·ªßa b·∫°n.
"""
    markup = telebot.types.InlineKeyboardMarkup()
    confirm_button = telebot.types.InlineKeyboardButton("‚úÖ T√¥i ƒë√£ tham gia nh√≥m", callback_data="confirm_group_join")
    markup.add(confirm_button)
    bot.send_message(user_id, welcome_message, reply_markup=markup, parse_mode='Markdown')

@bot.callback_query_handler(func=lambda call: call.data == "confirm_group_join")
def confirm_group_join_callback(call):
    user_id = call.from_user.id
    user_info = get_user_info(user_id)
    bot.answer_callback_query(call.id, "ƒêang ki·ªÉm tra th√†nh vi√™n nh√≥m...", show_alert=False)

    # !!! Thay th·∫ø -100xxxxxxxxxx b·∫±ng ID nh√≥m c·ªßa b·∫°n (b·∫Øt ƒë·∫ßu b·∫±ng -100) !!!
    group_chat_id = -1002075726245 # ƒê·ªîI ID NH√ìM C·ª¶A B·∫†N T·∫†I ƒê√ÇY!
    is_member = is_member_of_group(user_id, group_chat_id)

    if is_member:
        if not user_info.get("has_claimed_free_vip"):
            expiry = activate_vip(user_id, 7)
            user_info["has_claimed_free_vip"] = True
            save_data(USER_DATA_FILE, user_data)
            bot.send_message(user_id, f"üéâ **Ch√∫c m·ª´ng!** B·∫°n ƒë√£ tham gia nh√≥m th√†nh c√¥ng.\n\n**VIP 7 ng√†y mi·ªÖn ph√≠** c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t!\nüóìÔ∏è Th·ªùi gian h·∫øt h·∫°n: {expiry.strftime('%Y-%m-%d %H:%M:%S')}", parse_mode='Markdown')
            bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.message_id, text=call.message.text + "\n\n‚úÖ **B·∫°n ƒë√£ nh·∫≠n VIP 7 ng√†y mi·ªÖn ph√≠.**", parse_mode='Markdown')
        else:
            bot.send_message(user_id, "‚ÑπÔ∏è B·∫°n ƒë√£ nh·∫≠n VIP mi·ªÖn ph√≠ 7 ng√†y tr∆∞·ªõc ƒë√≥ r·ªìi.")
            bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.message_id, text=call.message.text + "\n\nB·∫°n ƒë√£ nh·∫≠n VIP mi·ªÖn ph√≠ r·ªìi.", parse_mode='Markdown')
    else:
        bot.send_message(user_id, f"‚ùå **B·∫°n ch∆∞a tham gia nh√≥m.** Vui l√≤ng tham gia nh√≥m: {GROUP_LINK} tr∆∞·ªõc khi nh·∫•n x√°c nh·∫≠n.", parse_mode='Markdown')

@bot.message_handler(commands=['help'])
def send_help(message):
    help_text = f"""
üìö **C√ÅC L·ªÜNH H·ªñ TR·ª¢** üìö
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üîç `/start` - B·∫Øt ƒë·∫ßu v√† nh·∫≠n th√¥ng tin ch√†o m·ª´ng.
üíé `/code [m√£]` - K√≠ch ho·∫°t m√£ VIP. Admin c√≥ th·ªÉ t·∫°o m√£ m·ªõi.
üìä `/stats` - Xem th·ªëng k√™ d·ª± ƒëo√°n c√° nh√¢n.
üìú `/history` - Xem l·ªãch s·ª≠ c√°c l·∫ßn d·ª± ƒëo√°n c·ªßa b·∫°n.
üì© `/invite` - L·∫•y link m·ªùi b·∫°n b√® nh·∫≠n VIP v√† nh·∫≠n th√™m ng√†y VIP.
üë§ `/id` - Xem th√¥ng tin t√†i kho·∫£n c·ªßa b·∫°n.
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
**ƒê·ªÉ ph√¢n t√≠ch MD5:**
    Ch·ªâ c·∫ßn g·ª≠i m√£ **MD5 (32 k√Ω t·ª±)** tr·ª±c ti·∫øp v√†o bot.
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üÜò H·ªó tr·ª£: {SUPPORT_USERNAME}
"""
    bot.send_message(message.chat.id, help_text, parse_mode='Markdown')

@bot.message_handler(commands=['gia'])
def send_price_list(message):
    price_text = """
üí∞ **B·∫¢NG GI√Å D·ªäCH V·ª§ VIP** üí∞
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚ú® **G√≥i C∆° B·∫£n (7 Ng√†y):** Mi·ªÖn ph√≠ (tham gia nh√≥m Telegram)
‚ú® **G√≥i Th∆∞·ªùng (30 Ng√†y):** 50.000 VNƒê
‚ú® **G√≥i Cao C·∫•p (Tr·ªçn ƒê·ªùi):** 200.000 VNƒê
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üí≥ ƒê·ªÉ mua VIP, vui l√≤ng li√™n h·ªá Admin/CTV ƒë·ªÉ ƒë∆∞·ª£c h∆∞·ªõng d·∫´n chi ti·∫øt.
"""
    bot.send_message(message.chat.id, price_text, parse_mode='Markdown')

@bot.message_handler(commands=['gopy'])
def receive_feedback(message):
    feedback = message.text.replace("/gopy", "").strip()
    if not feedback:
        bot.reply_to(message, "‚úçÔ∏è Vui l√≤ng nh·∫≠p n·ªôi dung g√≥p √Ω c·ªßa b·∫°n sau l·ªánh /gopy.\nV√≠ d·ª•: `/gopy Bot ho·∫°t ƒë·ªông r·∫•t t·ªët!`", parse_mode='Markdown')
        return

    for admin_id in ADMIN_IDS:
        try:
            bot.send_message(admin_id, f"üìù **G√ìP √ù M·ªöI** t·ª´ ng∆∞·ªùi d√πng ID: `{message.from_user.id}` (T√™n: `{message.from_user.first_name or 'N/A'}`)\n\nN·ªôi dung:\n__{feedback}__", parse_mode='Markdown')
        except Exception as e:
            print(f"Kh√¥ng th·ªÉ g·ª≠i g√≥p √Ω ƒë·∫øn Admin {admin_id}: {e}")
    bot.reply_to(message, "‚úÖ **C·∫£m ∆°n b·∫°n ƒë√£ g·ª≠i g√≥p √Ω!** Ch√∫ng t√¥i s·∫Ω xem x√©t v√† ph·∫£n h·ªìi s·ªõm nh·∫•t c√≥ th·ªÉ.")

@bot.message_handler(commands=['nap'])
def top_up_guide(message):
    bot.send_message(message.chat.id, "üí≥ **H∆Ø·ªöNG D·∫™N N·∫†P TI·ªÄN** üí≥\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nƒê·ªÉ n·∫°p ti·ªÅn ho·∫∑c mua c√°c g√≥i VIP, vui l√≤ng li√™n h·ªá tr·ª±c ti·∫øp v·ªõi ƒë·ªôi ng≈© Admin ho·∫∑c CTV c·ªßa ch√∫ng t√¥i ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£ v√† h∆∞·ªõng d·∫´n c·ª• th·ªÉ.\n\nüÜò Li√™n h·ªá h·ªó tr·ª£: {SUPPORT_USERNAME}", parse_mode='Markdown')

@bot.message_handler(commands=['taixiu'])
@vip_required
def get_latest_taixiu_prediction(message):
    user_id = message.from_user.id
    user_info = get_user_info(user_id)
    user_info["waiting_for_md5"] = True
    save_data(USER_DATA_FILE, user_data)
    bot.reply_to(message, "üìù **Vui l√≤ng g·ª≠i m√£ MD5 (32 k√Ω t·ª±)** ƒë·ªÉ t√¥i ti·∫øn h√†nh ph√¢n t√≠ch v√† ƒë∆∞a ra d·ª± ƒëo√°n.", parse_mode='Markdown')

@bot.message_handler(commands=['tat'])
def stop_notifications(message):
    bot.reply_to(message, "‚ÑπÔ∏è Ch·ª©c nƒÉng nh·∫≠n th√¥ng b√°o li√™n t·ª•c hi·ªán ch∆∞a ƒë∆∞·ª£c h·ªó tr·ª£. B·∫°n c√≥ th·ªÉ g·ª≠i m√£ MD5 b·∫•t c·ª© l√∫c n√†o ƒë·ªÉ nh·∫≠n d·ª± ƒëo√°n.")

@bot.message_handler(commands=['full'])
@admin_ctv_required
def view_user_details(message):
    args = message.text.split()
    if len(args) < 2:
        bot.reply_to(message, "üìù Vui l√≤ng nh·∫≠p ID ng∆∞·ªùi d√πng c·∫ßn xem. V√≠ d·ª•: `/full 123456789`", parse_mode='Markdown')
        return

    try:
        target_user_id = int(args[1])
        if target_user_id not in user_data:
            bot.reply_to(message, "Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng v·ªõi ID n√†y.")
            return

        target_user_info = get_user_info(target_user_id)
        vip_status = get_vip_status_text(target_user_id)

        total_predictions = target_user_info['correct_predictions'] + target_user_info['wrong_predictions']
        accuracy = 0.00
        if total_predictions > 0:
            accuracy = (target_user_info['correct_predictions'] / total_predictions) * 100

        response = f"""
üë§ **TH√îNG TIN CHI TI·∫æT NG∆Ø·ªúI D√ôNG** üë§
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üÜî ID: `{target_user_id}`
‚ú® T√™n: `{target_user_info.get('name', 'N/A')}`
üåü VIP: {vip_status}
üíå L∆∞·ª£t m·ªùi: {target_user_info['invite_count']}
‚úîÔ∏è ƒê√∫ng: {target_user_info['correct_predictions']}
‚ùå Sai: {target_user_info['wrong_predictions']}
üìä Ch√≠nh x√°c: {accuracy:.2f}%
üë®‚Äçüíª CTV: {'‚úÖ C√≥' if target_user_info['is_admin_ctv'] else '‚ùå Kh√¥ng'}
"""
        bot.reply_to(message, response, parse_mode='Markdown')
    except ValueError:
        bot.reply_to(message, "‚ùå ID ng∆∞·ªùi d√πng kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i.")

@bot.message_handler(commands=['giahan'])
@admin_ctv_required
def extend_vip(message):
    args = message.text.split()
    if len(args) < 3:
        bot.reply_to(message, "üìù Vui l√≤ng nh·∫≠p ID ng∆∞·ªùi d√πng v√† s·ªë ng√†y gia h·∫°n.\nV√≠ d·ª•: `/giahan 123456789 30`", parse_mode='Markdown')
        return

    try:
        target_user_id = int(args[1])
        days_to_add = int(args[2])

        if target_user_id not in user_data:
            bot.reply_to(message, "Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng v·ªõi ID n√†y.")
            return

        if days_to_add <= 0:
            bot.reply_to(message, "S·ªë ng√†y gia h·∫°n ph·∫£i l·ªõn h∆°n 0.")
            return

        new_expiry = activate_vip(target_user_id, days_to_add)
        bot.send_message(target_user_id, f"üéâ **T√†i kho·∫£n VIP c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c gia h·∫°n th√™m {days_to_add} ng√†y b·ªüi Admin/CTV!**\nüóìÔ∏è Th·ªùi gian h·∫øt h·∫°n m·ªõi: {new_expiry.strftime('%Y-%m-%d %H:%M:%S')}", parse_mode='Markdown')
        bot.reply_to(message, f"‚úÖ ƒê√£ gia h·∫°n VIP th√†nh c√¥ng cho ng∆∞·ªùi d√πng `{target_user_id}` th√™m {days_to_add} ng√†y.", parse_mode='Markdown')
    except ValueError:
        bot.reply_to(message, "‚ùå ID ng∆∞·ªùi d√πng ho·∫∑c s·ªë ng√†y kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i.")

@bot.message_handler(commands=['ctv'])
@super_admin_required
def add_ctv(message):
    args = message.text.split()
    if len(args) < 2:
        bot.reply_to(message, "üìù Vui l√≤ng nh·∫≠p ID ng∆∞·ªùi d√πng ƒë·ªÉ th√™m l√†m CTV. V√≠ d·ª•: `/ctv 123456789`", parse_mode='Markdown')
        return

    try:
        target_user_id = int(args[1])
        user_info = get_user_info(target_user_id)
        user_info["is_admin_ctv"] = True
        save_data(USER_DATA_FILE, user_data)
        bot.send_message(target_user_id, "üéâ **Ch√∫c m·ª´ng!** B·∫°n ƒë√£ ƒë∆∞·ª£c c·∫•p quy·ªÅn CTV!")
        bot.reply_to(message, f"‚úÖ ƒê√£ th√™m ng∆∞·ªùi d√πng `{target_user_id}` l√†m CTV.", parse_mode='Markdown')
    except ValueError:
        bot.reply_to(message, "‚ùå ID ng∆∞·ªùi d√πng kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i.")

@bot.message_handler(commands=['xoactv'])
@super_admin_required
def remove_ctv(message):
    args = message.text.split()
    if len(args) < 2:
        bot.reply_to(message, "üìù Vui l√≤ng nh·∫≠p ID ng∆∞·ªùi d√πng ƒë·ªÉ x√≥a CTV. V√≠ d·ª•: `/xoactv 123456789`", parse_mode='Markdown')
        return

    try:
        target_user_id = int(args[1])
        user_info = get_user_info(target_user_id)
        user_info["is_admin_ctv"] = False
        save_data(USER_DATA_FILE, user_data)
        bot.send_message(target_user_id, "üö® **Th√¥ng b√°o:** Quy·ªÅn CTV c·ªßa b·∫°n ƒë√£ b·ªã g·ª° b·ªè.")
        bot.reply_to(message, f"‚úÖ ƒê√£ x√≥a quy·ªÅn CTV c·ªßa ng∆∞·ªùi d√πng `{target_user_id}`.", parse_mode='Markdown')
    except ValueError:
        bot.reply_to(message, "‚ùå ID ng∆∞·ªùi d√πng kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i.")

@bot.message_handler(commands=['tb'])
@super_admin_required
def send_broadcast(message):
    broadcast_text = message.text.replace("/tb", "").strip()
    if not broadcast_text:
        bot.reply_to(message, "üìù Vui l√≤ng nh·∫≠p n·ªôi dung th√¥ng b√°o sau l·ªánh /tb.\nV√≠ d·ª•: `/tb Bot s·∫Ω b·∫£o tr√¨ v√†o 2h s√°ng.`", parse_mode='Markdown')
        return

    sent_count = 0
    # L·∫•y danh s√°ch c√°c ID ng∆∞·ªùi d√πng t·ª´ keys c·ªßa user_data, ƒë·∫£m b·∫£o l√† int
    all_user_ids = [uid for uid in user_data.keys()]

    bot.reply_to(message, f"ƒêang g·ª≠i th√¥ng b√°o t·ªõi {len(all_user_ids)} ng∆∞·ªùi d√πng. Vui l√≤ng ch·ªù...", parse_mode='Markdown')

    for user_id in all_user_ids:
        try:
            bot.send_message(user_id, f"üì£ **TH√îNG B√ÅO T·ª™ ADMIN:**\n\n{broadcast_text}", parse_mode='Markdown')
            sent_count += 1
            time.sleep(0.1)
        except Exception as e:
            print(f"Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o ƒë·∫øn ng∆∞·ªùi d√πng {user_id}: {e}")
    bot.reply_to(message, f"‚úÖ ƒê√£ g·ª≠i th√¥ng b√°o t·ªõi **{sent_count}** ng∆∞·ªùi d√πng.", parse_mode='Markdown')

@bot.message_handler(commands=['code'])
def handle_code(message):
    user_id = message.from_user.id
    args = message.text.split()

    if is_super_admin(user_id):
        if len(args) == 1: # Admin /code -> t·∫°o code m·ªõi
            new_code = generate_code()
            codes[new_code] = {"type": "admin_generated", "value": 15, "used_by": None} # M·∫∑c ƒë·ªãnh 15 ng√†y
            save_data(CODES_FILE, codes)
            bot.reply_to(message, f"‚úÖ ƒê√£ t·∫°o m√£ VIP m·ªõi: `{new_code}` (15 ng√†y VIP).\n\n_L∆∞u √Ω: B·∫°n c√≥ th·ªÉ ch·ªânh s·ª≠a s·ªë ng√†y trong codes.json n·∫øu c·∫ßn._", parse_mode='Markdown')
        elif len(args) == 2: # Admin /code <m√£> -> ƒë·ªÉ xem th√¥ng tin code ƒë√≥
            code_to_check = args[1].upper()
            if code_to_check in codes:
                code_info = codes[code_to_check]
                status = "Ch∆∞a s·ª≠ d·ª•ng" if code_info["used_by"] is None else f"ƒê√£ s·ª≠ d·ª•ng b·ªüi `{code_info['used_by']}`"
                bot.reply_to(message, f"""
üîë **TH√îNG TIN M√É VIP** üîë
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
M√£: `{code_to_check}`
Lo·∫°i: `{code_info['type']}`
Gi√° tr·ªã: `{code_info['value']}` ng√†y
Tr·∫°ng th√°i: `{status}`
""", parse_mode='Markdown')
            else:
                bot.reply_to(message, "‚ùå M√£ n√†y kh√¥ng t·ªìn t·∫°i trong h·ªá th·ªëng.", parse_mode='Markdown')
        else:
            bot.reply_to(message, "üìù L·ªánh `/code` d√†nh cho Admin:\n- `/code`: T·∫°o m√£ VIP m·ªõi.\n- `/code [m√£]`: Ki·ªÉm tra th√¥ng tin m√£ VIP c·ª• th·ªÉ.", parse_mode='Markdown')
        return

    # User uses /code [m√£]
    if len(args) < 2:
        bot.reply_to(message, "üìù Vui l√≤ng nh·∫≠p m√£ k√≠ch ho·∫°t VIP sau l·ªánh /code.\nV√≠ d·ª•: `/code CODEFREE7DAY`", parse_mode='Markdown')
        return

    user_code = args[1].upper()
    if user_code not in codes:
        bot.reply_to(message, "‚ùå M√£ k√≠ch ho·∫°t kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n.", parse_mode='Markdown')
        return

    code_info = codes[user_code]
    if code_info["used_by"] is not None:
        bot.reply_to(message, "‚ö†Ô∏è M√£ n√†y ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng b·ªüi ng∆∞·ªùi kh√°c r·ªìi.", parse_mode='Markdown')
        return
    
    # Ki·ªÉm tra ƒë·∫∑c bi·ªát cho CODEFREE7DAY: ch·ªâ d√πng 1 l·∫ßn/ID
    if user_code == "CODEFREE7DAY":
        user_info = get_user_info(user_id)
        if user_info.get("has_claimed_free_vip"):
            bot.reply_to(message, "‚ùå M√£ `CODEFREE7DAY` ch·ªâ c√≥ th·ªÉ s·ª≠ d·ª•ng **m·ªôt l·∫ßn duy nh·∫•t** cho m·ªói t√†i kho·∫£n.", parse_mode='Markdown')
            return
        user_info["has_claimed_free_vip"] = True # ƒê√°nh d·∫•u ƒë√£ s·ª≠ d·ª•ng
        save_data(USER_DATA_FILE, user_data)

    # K√≠ch ho·∫°t VIP cho ng∆∞·ªùi d√πng
    days = code_info["value"]
    expiry = activate_vip(user_id, days)
    code_info["used_by"] = user_id # ƒê√°nh d·∫•u m√£ ƒë√£ s·ª≠ d·ª•ng
    save_data(CODES_FILE, codes)

    bot.reply_to(message, f"üéâ **Ch√∫c m·ª´ng!** B·∫°n ƒë√£ k√≠ch ho·∫°t VIP th√†nh c√¥ng v·ªõi m√£ `{user_code}`.\n\nTh·ªùi gian VIP c·ªßa b·∫°n k√©o d√†i th√™m **{days} ng√†y** v√† s·∫Ω h·∫øt h·∫°n v√†o: {expiry.strftime('%Y-%m-%d %H:%M:%S')}", parse_mode='Markdown')


@bot.message_handler(commands=['stats'])
def show_stats(message):
    user_id = message.from_user.id
    user_info = get_user_info(user_id)

    total_predictions = user_info['correct_predictions'] + user_info['wrong_predictions']
    accuracy = 0.00
    if total_predictions > 0:
        accuracy = (user_info['correct_predictions'] / total_predictions) * 100

    stats_message = f"""
üìà **TH·ªêNG K√ä D·ª∞ ƒêO√ÅN C√Å NH√ÇN** üìà
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚úîÔ∏è S·ªë l·∫ßn d·ª± ƒëo√°n ƒë√∫ng: **{user_info['correct_predictions']}**
‚ùå S·ªë l·∫ßn d·ª± ƒëo√°n sai: **{user_info['wrong_predictions']}**
üìä T·ª∑ l·ªá ch√≠nh x√°c: **{accuracy:.2f}%**
"""
    bot.send_message(user_id, stats_message, parse_mode='Markdown')

@bot.message_handler(commands=['history'])
@vip_required # Y√™u c·∫ßu VIP ƒë·ªÉ xem l·ªãch s·ª≠ chi ti·∫øt
def show_history(message):
    user_id = message.from_user.id
    user_info = get_user_info(user_id)

    history_text = "üìú **L·ªäCH S·ª¨ D·ª∞ ƒêO√ÅN C·ª¶A B·∫†N** üìú\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
    if not user_info['history']:
        history_text += "B·∫°n ch∆∞a c√≥ l·ªãch s·ª≠ d·ª± ƒëo√°n n√†o."
    else:
        # Hi·ªÉn th·ªã 5-10 l·ªãch s·ª≠ g·∫ßn nh·∫•t
        for entry in user_info['history'][-10:]: # L·∫•y 10 m·ª•c g·∫ßn nh·∫•t
            status = "‚úÖ ƒê√öNG" if entry['is_correct'] else "‚ùå SAI"
            history_text += f"- MD5: `{entry['md5_short']}` | D·ª± ƒëo√°n: **{entry['prediction']}** | K·∫øt qu·∫£: **{entry['result_md5']}** | Status: **{status}** | L√∫c: {entry['time']}\n"
        
        if len(user_info['history']) > 10:
            history_text += "\n_... v√† nhi·ªÅu h∆°n n·ªØa. Ch·ªâ hi·ªÉn th·ªã 10 m·ª•c g·∫ßn nh·∫•t._"

    bot.send_message(user_id, history_text, parse_mode='Markdown')

@bot.message_handler(commands=['invite', 'moiban'])
def send_invite_link(message):
    user_id = message.from_user.id
    user_info = get_user_info(user_id)
    bot_username = bot.get_me().username
    invite_link = f"https://t.me/{bot_username}?start={user_id}"

    user_info["invite_link_generated"] = True
    save_data(USER_DATA_FILE, user_data)

    invite_message = f"""
üíå **M·ªúI B·∫†N B√à, NH·∫¨N VIP MI·ªÑN PH√ç!** üíå
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üì¢ Chia s·∫ª link n√†y ƒë·ªÉ m·ªùi b·∫°n b√® tham gia bot:
üîó **Link m·ªùi c·ªßa b·∫°n:** `{invite_link}`

üéÅ C·ª© m·ªói 1 ng∆∞·ªùi b·∫°n m·ªùi th√†nh c√¥ng (tham gia bot v√† ƒë∆∞·ª£c bot ghi nh·∫≠n), b·∫°n s·∫Ω nh·∫≠n ƒë∆∞·ª£c **1 ng√†y VIP mi·ªÖn ph√≠**!
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üë• T·ªïng s·ªë l∆∞·ª£t m·ªùi th√†nh c√¥ng c·ªßa b·∫°n: **{user_info['invite_count']}**
"""
    bot.send_message(user_id, invite_message, parse_mode='Markdown')

@bot.message_handler(commands=['id'])
def show_account_info(message):
    user_id = message.from_user.id
    user_info = get_user_info(user_id)

    vip_status_text = get_vip_status_text(user_id)
    vip_status_line1 = vip_status_text.splitlines()[0]
    vip_expiry_line = vip_status_text.splitlines()[1].replace('üóìÔ∏è H·∫øt h·∫°n: ', '') if len(vip_status_text.splitlines()) > 1 else 'N/A'

    total_predictions = user_info['correct_predictions'] + user_info['wrong_predictions']
    accuracy = 0.00
    if total_predictions > 0:
        accuracy = (user_info['correct_predictions'] / total_predictions) * 100

    account_info_message = f"""
üë§ **TH√îNG TIN T√ÄI KHO·∫¢N C·ª¶A B·∫†N** üë§
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚ú® T√™n: **{user_info.get('name', message.from_user.first_name)}**
üÜî ID: `{user_id}`
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üíé Tr·∫°ng th√°i VIP: **{vip_status_line1}**
‚è∞ H·∫øt h·∫°n: **{vip_expiry_line}**
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚úâÔ∏è L∆∞·ª£t m·ªùi th√†nh c√¥ng: **{user_info['invite_count']}**
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üìä **Th·ªëng k√™ d·ª± ƒëo√°n:**
    ‚úîÔ∏è ƒê√∫ng: **{user_info['correct_predictions']}**
    ‚ùå Sai: **{user_info['wrong_predictions']}**
    üéØ T·ª∑ l·ªá ch√≠nh x√°c: **{accuracy:.2f}%**
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üÜò H·ªó tr·ª£: {SUPPORT_USERNAME}
"""
    bot.send_message(user_id, account_info_message, parse_mode='Markdown')

# --- X·ª≠ l√Ω tin nh·∫Øn vƒÉn b·∫£n (MD5, v.v.) ---
@bot.message_handler(func=lambda message: True)
@vip_required
def handle_text_messages(message):
    user_id = message.from_user.id
    user_info = get_user_info(user_id)
    text = message.text.strip()

    # Ki·ªÉm tra n·∫øu ƒëang ch·ªù MD5 HO·∫∂C tin nh·∫Øn c√≥ v·∫ª l√† MD5
    if user_info["waiting_for_md5"] or re.fullmatch(r"[0-9a-fA-F]{32}", text):
        if re.fullmatch(r"[0-9a-fA-F]{32}", text):
            predicted_result, result_md5, is_correct, analysis_output = custom_md5_analyzer(text)
            
            if predicted_result is not None:
                bot.reply_to(message, analysis_output, parse_mode='Markdown')

                # C·∫≠p nh·∫≠t th·ªëng k√™ v√† l·ªãch s·ª≠
                if is_correct:
                    user_info["correct_predictions"] += 1
                else:
                    user_info["wrong_predictions"] += 1
                
                # Th√™m v√†o l·ªãch s·ª≠
                user_info["history"].append({
                    "md5_short": f"{text[:4]}...{text[-4:]}",
                    "prediction": predicted_result,
                    "result_md5": result_md5,
                    "is_correct": is_correct,
                    "time": datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                })
                # Gi·ªõi h·∫°n l·ªãch s·ª≠ ƒë·ªÉ kh√¥ng qu√° l·ªõn (v√≠ d·ª•: 50 m·ª•c)
                user_info["history"] = user_info["history"][-50:]

                save_data(USER_DATA_FILE, user_data)
            else:
                bot.reply_to(message, analysis_output) # Hi·ªÉn th·ªã l·ªói n·∫øu c√≥
            
            user_info["waiting_for_md5"] = False
            save_data(USER_DATA_FILE, user_data)
        else:
            bot.reply_to(message, "‚ùå M√£ MD5 kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p ƒë√∫ng **32 k√Ω t·ª± MD5** (ch·ªâ ch·ª©a ch·ªØ s·ªë 0-9 v√† ch·ªØ c√°i a-f).", parse_mode='Markdown')
    else:
        bot.reply_to(message, "ü§î T√¥i kh√¥ng hi·ªÉu y√™u c·∫ßu c·ªßa b·∫°n. Vui l√≤ng s·ª≠ d·ª•ng c√°c l·ªánh c√≥ s·∫µn (v√≠ d·ª•: `/help`) ho·∫∑c g·ª≠i m√£ MD5 ƒë·ªÉ t√¥i ph√¢n t√≠ch.", parse_mode='Markdown')


# --- Keep alive server ---
app = Flask(__name__)

@app.route('/')
def home():
    return "Bot is alive!"

def run_flask_app():
    port = random.randint(2000, 9000) # Random port
    print(f"Flask app running on port {port}")
    app.run(host='0.0.0.0', port=port)

# --- Kh·ªüi ch·∫°y bot ---
if __name__ == "__main__":
    user_data = load_data(USER_DATA_FILE)
    codes = load_data(CODES_FILE, default_data=codes) # Load codes, d√πng default n·∫øu file r·ªóng
    print("Bot ƒëang kh·ªüi ƒë·ªông...")

    # Ch·∫°y Flask app trong m·ªôt thread ri√™ng
    t = Thread(target=run_flask_app)
    t.start()

    bot.polling(non_stop=True)
